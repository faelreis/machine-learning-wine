# -*- coding: utf-8 -*-
"""ex-wine.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oBO9BkFqrurf5OZ3ILNoB37Y22RACKh1
"""

# Importando as bibliotecas necessárias
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.neural_network import MLPClassifier
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, roc_auc_score, roc_curve, confusion_matrix
import matplotlib.pyplot as plt
import seaborn as sns

# Carregando a base de dados wine
wine = pd.read_csv('https://archive.ics.uci.edu/ml/machine-learning-databases/wine/wine.data', header=None)

# Separando os dados em variáveis independentes e dependentes
X = wine.iloc[:, 1:].values
y = wine.iloc[:, 0].values

# Dividindo em conjunto de treinamento e teste
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Pré-processando os dados com o StandardScaler
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# Criando a rede neural com a classe MLPClassifier
clf = MLPClassifier(hidden_layer_sizes=(30, 30), max_iter=1000)

# Treinando a rede neural com os dados de treinamento
clf.fit(X_train, y_train)

# Treinar modelo
train_loss = []
test_loss = []
train_acc = []
test_acc = []
for i in range(100):
    clf.partial_fit(X_train, y_train, classes=np.unique(y_train))
    train_loss.append(clf.loss_)
    test_loss.append(clf.loss_)
    train_acc.append(clf.score(X_train, y_train))
    test_acc.append(clf.score(X_test, y_test))

# Fazendo as previsões para os dados de teste
y_pred = clf.predict(X_test)

# Calculando as métricas
accuracy = accuracy_score(y_test, y_pred)
precision = precision_score(y_test, y_pred, average='weighted')
recall = recall_score(y_test, y_pred, average='weighted')
f1 = f1_score(y_test, y_pred, average='weighted')
auc = roc_auc_score(y_test, clf.predict_proba(X_test), multi_class='ovr')
fpr, tpr, thresholds = roc_curve(y_test, clf.predict_proba(X_test)[:,1], pos_label=1)
cm = confusion_matrix(y_test, y_pred)

# Apresentando as métricas
print("Acurácia:", accuracy)
print("Precisão:", precision)
print("Recall:", recall)
print("F1-score:", f1)
print("AUC:", auc)

# Apresentando a curva ROC
plt.plot(fpr, tpr, label='ROC curve')
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('ROC curve')
plt.legend(loc="lower right")
plt.show()

# Apresentando a matriz de confusão
print("Matriz de confusão:\n", cm)

# Calcular a matriz de confusão
plt.figure(figsize=(10,5))
sns.heatmap(cm, annot=True)

# Mostrar a matriz de confusão
print(cm)

# Plotar gráfico de desempenho e perda
import matplotlib.pyplot as plt
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8))
ax1.plot(train_acc, label='Treino')
ax1.plot(test_acc, label='Teste')
ax1.set_ylabel('Acurácia')
ax1.legend()
ax2.plot(train_loss, label='Treino')
ax2.plot(test_loss, label='Teste')
ax2.set_ylabel('Perda')
ax2.set_xlabel('Época')
ax2.legend()
plt.show()